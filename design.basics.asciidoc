= Ehcache Design Fundamentals

:toc:

== `CacheManager`, `Cache` and their dependencies

As in the 1.x & 2.x line, Ehcache has the notion of a `CacheManager`, who manages `Cache` instances. Managing a `Cache`
means fulfilling a couple of roles:

 - Life cycling it: e.g. `.init()`, `.closing()` the `Cache`;
 - Providing it with `Service` instance: A `CacheManager` comes with a set of base abstract services `Cache` can use
 and that it will lifecycle too; but the `CacheManager` can lifecycle any amount of additional `Service` types that
 gets registered with it. These `Service` can then be looked up, e.g. by `Cache` or other `Service` instances, using the
 `ServiceProvider` interface;
 - Finally, the `CacheManager` acts as a repository of alias'ed `Cache` instances. Unlike in the previous versions, `Cache`
 instances aren't named, but are registered with the `CacheManager` under an _alias_. The `Cache` is never aware of it.

This diagram tries to summarize the different roles:

image::https://raw.githubusercontent.com/ehcache/ehcache3/master/docs/images/design/basics/baseTypes.png[Base Types]

A user will only mostly interact with the `CacheManager` and `Cache` API types... He may need to configure specific
`Service` types for his `Cache` instances to use. See <<configuration-types-and-builders>>

=== The `CacheManager`

While the `CacheManager` does act as a repository, it is _not_ possible to add a `Cache` directly to a `CacheManager`.
A `Cache` can be created by a `CacheManager`, which will then keep a reference to it, alias'ed to a user provided name.
To remove that `Cache` from the `CacheManager`, it has to be explicitly removed using `CacheManager.removeCache(String)`.
Upon that method successfully returning, the `Cache` 's status will be `Status.UNINITIALIZED` and as such will not be
usable anymore, see <<state-transitions>> section below.

=== The `Cache`

A `Cache` is backed by a `Store` where all cached entries (i.e. key to value mappings) are held. The `Cache` doesn't know
what topology this `Store` is using; whether it's storing these entries on the JVM's heap, off the heap, on disk, on a remote
JVM or any combination of the above.

When a `Cache` is being constructed, e.g. by the `CacheManager` on a `.createCache()` method invoke, the `CacheManager`
will lookup a `Store.Provider` which is one of the bundled `Service` types of Ehcache, asking it to create a `Store` based
on the `CacheConfiguration` used to configure the given `Cache`. That indirection, makes both the `Cache` as well as the
`CacheManager` ignorant of what topology this `Cache` is to use. Ehcache comes with a `DefaultStoreProvider` that will
be loaded by the `ServiceProvider`, should one be explicitly provided. That in turn will resolve the required `Store`
instance to be provided to the `Cache` being created.

image::https://raw.githubusercontent.com/ehcache/ehcache3/master/docs/images/design/basics/cacheStore.png[Cache's Store]

The `Cache` also tries to never _fails_ on operations invoked, e.g. a get shouldn't result in throwing an exception if the
`Store` that backs it up uses serialization and fails to retrieve the mapping. Instead, Ehcache tries to be resilient and
should try to clear that mapping from its `Store` and return `null` instead to the user. It is the responsibility of the
`Cache` to handle the exceptions a `Store` may throw (the `Store` interface explicitly declares it throws
`CacheAccessException`, which is a checked exception). The `Cache` will delegate failures to the `ResilienceStrategy`,
which in turn is responsible for handling the failure.

Currently, Ehcache only has a single `ResilienceStrategy`, which is supporting single-JVM deployments, and will try to
_heal_ the `Store` on failure and making the invoking action on a `Cache` a no-op. We'll add more `ResilienceStrategy`
and will make it pluggable, when we move on to distributed topologies.

=== The new `UserManagedCache`

The `UserManagedCache` are, as the name implies, managed by the user instead of being managed by a `CacheManager`. While
these instances a meant to be lightweight, short-lived ones, nothing prohibits a user from building a distributed
`UserManagedCache` if so desired.

As the user manages that instance himself, he needs to provide all `Service` instances required by the `UserManagedCache`.
Also he'll need to invoke lifecycle methods on it (see <<state-transitions>>) and finally keep a reference to it, as it
won't available in any `CacheManager`.

image::https://raw.githubusercontent.com/ehcache/ehcache3/master/docs/images/design/basics/userManagedCache.png[UserManagedCache]

== State transitions

A lifecycled instance, e.g. a `CacheManager` or a `UserManagedCache`, have three states represented by the
`org.ehcache.Status` enum:

 . `UNINITIALIZED`: The instance can't be used, it probably just got instantiated or got `.close()` invoked on it;
 . `MAINTENANCE`: The instance is only usable by the thread that got the _maintenance lease_ for it. Special maintenance
 operations can be performed on the instance;
 . `AVAILABLE`: The operational state of the instance, all operations can be performed by any amount of threads.

image::https://raw.githubusercontent.com/ehcache/ehcache3/master/docs/images/design/basics/stateTransitions.png[Statuses & transitions]

State should only be maintained at the _higher_ user-visible API instance, e.g. a concrete `Cache` instance like `Ehcache`.
That means that it is the warrant for blocking operations during state transitions or on an _illegal state_. No need for
the underlying data structure to do so too (e.g. `Store`), as this would come to much higher cost during runtime.

NOTE: A generic utility class `StatusTransitioner` encapsulate that responsibility and should be reusable across types that
require enforcing lifecycle constraints.

== Configuration types and builders

In the most generic sense, configuration types are used to _configure_ a given service _while_ it's being constructed. A
builder exposes a user-friendly DSL to configure and build _runtime instances_ (e.g. `CacheManager`). Finally runtime
configuration types are configured from configuration types and used at runtime by the actual configured instance,
providing a way for the user to mutate the behavior of that instance at runtime in limited ways.

=== Configurations

image::https://raw.githubusercontent.com/ehcache/ehcache3/master/docs/images/design/basics/config.png[Configuration types]

=== Builder guidelines

== The `PersistentCacheManager`

=== `CacheManagerBuilder.with()` 's extension point

=== Locally persistent

=== Clustered topology
